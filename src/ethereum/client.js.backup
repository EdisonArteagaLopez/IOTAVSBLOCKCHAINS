import { ethers } from 'ethers';
import dotenv from 'dotenv';
import logger from '../utils/logger.js';

dotenv.config();

class EthereumClient {
  constructor() {
    this.rpcUrl = process.env.SEPOLIA_RPC_URL || 'https://rpc.sepolia.org';
    this.provider = new ethers.JsonRpcProvider(this.rpcUrl);
    
    if (process.env.SEPOLIA_PRIVATE_KEY) {
      this.wallet = new ethers.Wallet(process.env.SEPOLIA_PRIVATE_KEY, this.provider);
    }
    
    this.address = process.env.SEPOLIA_ADDRESS;
  }

  async getBlockNumber() {
    try {
      return await this.provider.getBlockNumber();
    } catch (error) {
      logger.error('Error getting block number', error);
      throw error;
    }
  }

  async isConnected() {
    try {
      const blockNumber = await this.getBlockNumber();
      const network = await this.provider.getNetwork();
      
      logger.info('Connected to Ethereum network', {
        network: network.name,
        chainId: network.chainId.toString(),
        blockNumber
      });
      return true;
    } catch (error) {
      logger.error('Cannot connect to Ethereum network');
      return false;
    }
  }

  async getBalance(address = null) {
    try {
      const addr = address || this.address;
      const balance = await this.provider.getBalance(addr);
      return ethers.formatEther(balance);
    } catch (error) {
      logger.error('Error getting balance', error);
      throw error;
    }
  }

  async getGasPrice() {
    try {
      const feeData = await this.provider.getFeeData();
      return {
        gasPrice: feeData.gasPrice,
        maxFeePerGas: feeData.maxFeePerGas,
        maxPriorityFeePerGas: feeData.maxPriorityFeePerGas
      };
    } catch (error) {
      logger.error('Error getting gas price', error);
      throw error;
    }
  }

  async sendTransaction(to, valueInEth = '0.0001') {
    if (!this.wallet) {
      throw new Error('Wallet not configured. Set SEPOLIA_PRIVATE_KEY in .env');
    }

    try {
      const startTime = Date.now();
      const cpuStart = process.cpuUsage();

      const tx = await this.wallet.sendTransaction({
        to,
        value: ethers.parseEther(valueInEth),
        gasLimit: 21000
      });

      const sendTime = Date.now();

      // Esperar confirmación
      const receipt = await tx.wait();

      const endTime = Date.now();
      const cpuEnd = process.cpuUsage(cpuStart);
      const cpuTime = (cpuEnd.user + cpuEnd.system) / 1000; // microsegundos

      return {
        hash: tx.hash,
        from: receipt.from,
        to: receipt.to,
        gasUsed: receipt.gasUsed.toString(),
        effectiveGasPrice: receipt.gasPrice?.toString() || '0',
        gasCost: ethers.formatEther(
          BigInt(receipt.gasUsed) * (receipt.gasPrice || 0n)
        ),
        blockNumber: receipt.blockNumber,
        status: receipt.status === 1,
        latency: endTime - startTime,
        sendLatency: sendTime - startTime,
        confirmLatency: endTime - sendTime,
        cpuTime,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      logger.error('Error sending transaction', error);
      throw error;
    }
  }

  async storeData(data) {
    if (!this.wallet) {
      throw new Error('Wallet not configured. Set SEPOLIA_PRIVATE_KEY in .env');
    }

    try {
      const startTime = Date.now();
      const cpuStart = process.cpuUsage();

      // Convertir datos a hexadecimal
      const dataHex = ethers.hexlify(ethers.toUtf8Bytes(
        typeof data === 'string' ? data : JSON.stringify(data)
      ));

      // Enviar transacción con datos
      const tx = await this.wallet.sendTransaction({
        to: this.address, // Enviar a nosotros mismos
        value: 0,
        data: dataHex,
        gasLimit: 50000 + (dataHex.length * 16) // Aproximación
      });

      const sendTime = Date.now();
      const receipt = await tx.wait();
      const endTime = Date.now();
      const cpuEnd = process.cpuUsage(cpuStart);

      return {
        hash: tx.hash,
        gasUsed: receipt.gasUsed.toString(),
        gasCost: ethers.formatEther(
          BigInt(receipt.gasUsed) * (receipt.gasPrice || 0n)
        ),
        dataSize: dataHex.length / 2, // bytes
        latency: endTime - startTime,
        cpuTime: (cpuEnd.user + cpuEnd.system) / 1000,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      logger.error('Error storing data', error);
      throw error;
    }
  }

  async retrieveData(txHash) {
    try {
      const tx = await this.provider.getTransaction(txHash);
      
      if (tx && tx.data && tx.data !== '0x') {
        const dataString = ethers.toUtf8String(tx.data);
        try {
          return JSON.parse(dataString);
        } catch {
          return dataString;
        }
      }
      
      return null;
    } catch (error) {
      logger.error('Error retrieving data', error);
      throw error;
    }
  }

  async getTransactionReceipt(txHash) {
    try {
      return await this.provider.getTransactionReceipt(txHash);
    } catch (error) {
      logger.error('Error getting transaction receipt', error);
      throw error;
    }
  }

  async estimateGas(to, data = '0x') {
    try {
      const gasEstimate = await this.provider.estimateGas({
        to,
        data
      });
      
      const feeData = await this.provider.getFeeData();
      const gasCost = ethers.formatEther(
        gasEstimate * (feeData.gasPrice || 0n)
      );

      return {
        gasLimit: gasEstimate.toString(),
        gasPrice: feeData.gasPrice?.toString() || '0',
        estimatedCost: gasCost
      };
    } catch (error) {
      logger.error('Error estimating gas', error);
      throw error;
    }
  }

  async waitForTransaction(txHash, confirmations = 1, timeout = 120000) {
    try {
      const receipt = await this.provider.waitForTransaction(
        txHash,
        confirmations,
        timeout
      );
      return receipt;
    } catch (error) {
      logger.error('Error waiting for transaction', error);
      throw error;
    }
  }

  async getNetworkStats() {
    try {
      const blockNumber = await this.provider.getBlockNumber();
      const block = await this.provider.getBlock(blockNumber);
      const feeData = await this.provider.getFeeData();

      return {
        blockNumber,
        timestamp: block.timestamp,
        gasLimit: block.gasLimit.toString(),
        gasUsed: block.gasUsed.toString(),
        baseFeePerGas: block.baseFeePerGas?.toString() || '0',
        currentGasPrice: feeData.gasPrice?.toString() || '0'
      };
    } catch (error) {
      logger.error('Error getting network stats', error);
      return null;
    }
  }
}

export default EthereumClient;
export default EthereumClient;
